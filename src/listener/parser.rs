use std::net::IpAddr;
use std::str::FromStr;

use crate::probe::iperf_json::IperfResponse;
use crate::prost_net::bandwidth_client::{ClientEventResult, ClientHandlerEvent};
use crate::CONFIG;

use super::procfs_reader::{self, get_interface, get_interface_info, NetStat};
use super::tracking::link::LinkManager;

use crate::{
    stream_id::from_iperf_connected, CapEvent, CapEventReceiver, OwnedPacket, PCAPMeta,
    ParsedPacket, Settings,
};
use anyhow::Result;
use log::{error, info};
use neli_wifi::{Bss, Station};
use pnet::packet::ip::IpNextHeaderProtocols;
use std::sync::Arc;
use tokio::task::JoinHandle;
use tokio::{
    sync::mpsc::{channel, Receiver, Sender},
    time,
};

const CHANNEL_CAPACITY: usize = 10; // Capacity for most MPSC channels in number of messages.

#[derive(Debug)]
pub struct NetlinkData {
    /// List of currently connected stations
    pub stations: Vec<Station>,
    /// BSS information for each station
    pub bss: Vec<Bss>,
}

/// Periodic observations from netlink + /proc/net.
pub struct PeriodicData {
    /// Optional wireless state at the moment (if a the used device is a WiFi device)
    pub netlink_data: Option<NetlinkData>,
    /// Connection states for all TCP and UDP connections with byte/counter statistics
    pub netstat_data: NetStat,
}

/// The main packet and control event parser:
/// • Consumes captured packets and iperf JSON responses.
/// • Periodically polls system/network state.
/// • Forwards parsed bandwidth estimates to the `LinkManager`.
pub struct Parser {
    packet_stream: CapEventReceiver,
    pcap_meta: Arc<PCAPMeta>,
    link_manager: LinkManager,
    netlink_data: Vec<NetlinkData>,
    netstat_data: Option<NetStat>,
    crx: Receiver<ClientEventResult>,
}

impl Parser {
    /// Create a new `Parser` and its matching `ClientEventResult` sender.
    ///
    /// # Arguments
    ///
    /// * `packet_stream` – channel receiving `CapEvent`s, including packets, ping, pathload, etc.
    /// * `pcap_meta` – metadata about this host’s capture interface (MAC, IP).
    /// * `client_sender` – channel sender for pushing `ClientHandlerEvent`s (e.g. to the gRPC client).
    ///
    /// # Returns
    ///
    /// A tuple of `(Parser, Sender<ClientEventResult>)`. The caller holds the `Sender`
    /// to send back results for events generated by the client (e.g. TRex/iperf).
    pub fn new(
        packet_stream: CapEventReceiver,
        // "Metadata" from the pcap capture, aka this devices MAC and IP addresses
        pcap_meta: Arc<PCAPMeta>,
        client_sender: Sender<ClientHandlerEvent>,
    ) -> Result<(Self, Sender<ClientEventResult>)> {
        let (ctx, crx): (Sender<ClientEventResult>, Receiver<ClientEventResult>) =
            channel(CHANNEL_CAPACITY);
        Ok((
            Parser {
                packet_stream,
                pcap_meta: pcap_meta.clone(),
                link_manager: LinkManager::new(client_sender, pcap_meta.clone()),
                netlink_data: Vec::new(),
                netstat_data: None,
                crx,
            },
            ctx,
        ))
    }

    /// Spawn the parser’s main loop onto the Tokio runtime.
    ///
    /// Returns a `JoinHandle` which can be `.await`ed or `.abort()`ed.
    pub fn dispatch_parser(self) -> JoinHandle<()> {
        tokio::spawn(async move { self.start().await })
    }


    /// The main asynchronous event loop.
    ///
    /// Handles:
    ///  - incoming `CapEvent`s (packets, iperf, pings, etc.),
    ///  - periodic system polls,
    ///  - client replies (e.g. iperf ready notifications),
    ///  - cleanup intervals,
    ///  - measurement windows triggering bandwidth reports (as well as
    /// rtt/packet gap data reports if enabled).
    pub async fn start(mut self) {
        // Resolve the numeric interface index for wireless netlink if available.
        let interface = match get_interface(&self.pcap_meta.name).await {
            Ok(interface) => {
                info!("Interface: {:?}", interface);
                Some(interface)
            }
            Err(e) => {
                error!("Failed to get interface index: {}", e);
                None
            }
        };

        let idx = match interface {
            Some(interface) => interface.index,
            None => None,
        };

        // Spawn the periodic poller
        let (ptx, mut prx): (Sender<PeriodicData>, Receiver<PeriodicData>) =
            channel(CHANNEL_CAPACITY);

        let periodic_handle = tokio::spawn(async move {
            Parser::periodic(ptx, idx).await;
        });

        // Set up timers
        let mut measurement_window = time::interval(CONFIG.client.measurement_window);
        let mut interval = time::interval(Settings::CLEANUP_INTERVAL);

        loop {
            tokio::select! {
                // Received MPSC data from the packet capture or another source
                // Some of these events remains unused, but are kept for future use
                Some(cap_ev) = self.packet_stream.recv() => {
                    match cap_ev {
                        CapEvent::Packet(packet) => {
                            self.handle_capture(packet);
                        }
                        CapEvent::IperfResponse(data) => {
                            self.handle_iperf(data);
                        }
                        CapEvent::Protobuf(pbf) => {
                            info!("Received protobuf: {:?}", pbf);
                        }
                        CapEvent::PathloadResponse(s) => {
                            info!("Received pathload response: {:?}", s);
                        }
                        CapEvent::PingResponse(res) => {
                            info!("Received ping response: {:?}", res);
                        }
                        CapEvent::Error(e) => {
                            error!("Error received: {:?}", e);
                        }
                    }
                },

                // Received netlink/procfs data from the periodic poller
                Some(periodic_data) = prx.recv() => {
                    self.handle_periodic(periodic_data);
                },

                // Replies from the gRPC client (e.g. server connected)
                Some(reply) = self.crx.recv() => {
                    match reply {
                        ClientEventResult::ServerConnected(ip) => {
                            self.link_manager.add_important_link(IpAddr::from_str(ip.as_str()));
                        },
                        _ => info!("Received reply: {:?}", reply),
                    }
                },

                // Routine cleanup
                _ = interval.tick() => {
                    self.link_manager.periodic().await;
                },

                // Trigger bandwidth summary reporting
                _ = measurement_window.tick() => {
                    self.link_manager.send_bandwidth().await;
                    self.link_manager.send_init_clients_msg().await;
                },
                else => {
                    // Both streams have ended
                    self.stop(vec![periodic_handle]).await;
                    break;
                }
            }
        }
    }

    pub async fn stop(self, handles: Vec<tokio::task::JoinHandle<()>>) {
        // Stop the parser
        for handle in handles {
            handle.abort();
        }
    }

    /// Periodically polls procfs and netlink at the given interface index.
    ///
    /// Sends `PeriodicData` to the provided channel until it is closed.
    async fn periodic(tx: Sender<PeriodicData>, idx: Option<i32>) {
        loop {
            let netstat = procfs_reader::proc_net().await;
            let interface = match idx {
                Some(idx) => Some(get_interface_info(idx).await.unwrap()),
                None => None,
            };

            let data = PeriodicData {
                netlink_data: interface,
                netstat_data: netstat,
            };

            if tx.send(data).await.is_err() {
                break;
            }

            time::sleep(Settings::CLEANUP_INTERVAL).await;
        }
    }


    /// Integrate a new `PeriodicData` sample into our sliding windows.
    fn handle_periodic(&mut self, data: PeriodicData) {
        match data.netlink_data {
            Some(data) => self.netlink_data.push(data),
            _ => (),
        }
        if self.netlink_data.len() > 10 {
            self.netlink_data.remove(0);
        }

        self.netstat_data = Some(data.netstat_data);
    }

    /// Parse and forward a single captured packet to the `LinkManager`.
    fn handle_capture(&mut self, packet: OwnedPacket) {
        // Handle the captured packet
        let parsed_packet = match ParsedPacket::from_packet(&packet, &self.pcap_meta) {
            Some(packet) => packet,
            None => return,
        };

        self.link_manager.insert(parsed_packet);
    }

    /// Handle an iperf JSON response, extract throughput, and forward to the `LinkManager`.
    fn handle_iperf(&mut self, iperf_data: IperfResponse) {
        match iperf_data {
            IperfResponse::Error(_) => {
                // Do nothing for now
            }
            IperfResponse::Success(s) => {
                let connected = s.start.connected;
                if connected.len() == 1 {
                    let (_, ip_pair) = from_iperf_connected(
                        connected.first().unwrap(),
                        IpNextHeaderProtocols::Tcp,
                    );

                    let mut stream = None;
                    if s.end.sum_sent.sender == true {
                        // We are the client.
                        if let Some(strm) = s.end.streams.first().take() {
                            stream = Some(strm);
                        }
                    }

                    self.link_manager.insert_iperf_result(
                        ip_pair,
                        s.end
                            .sum_received
                            .bits_per_second
                            .max(s.end.sum_sent.bits_per_second),
                        stream,
                    ); // ! FIXME This is a hack
                }
            }
        }
    }
}
